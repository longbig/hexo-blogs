---
title: mysql索引基础
date: 2021-04-17 21:05:25
type: "_posts"
layout: "posts"
---

## 索引常见模型

### 三种数据结构

* 三种数据结构：哈希表，有序数组，搜索树；
* 哈希表结构适用于等值查询的场景
* 有序数组适用于静态存储引擎，查询多，改动少；
* 二叉搜索树:查找 O(logN)，插入也是O(logN)；

### Innodb的索引模型

1.每一个索引在 innodb里对应一棵B+树；

2.根据叶子节点内容分：主键索引和非主键索引：

* 主键索引：叶子节点存整行数据；
* 非主键索引：叶子节点存主键的值；

3.**提问：基于主键索引和普通索引的查询有什么区别？**

* 查询语句：`select * from T where ID = 1`主键查询方式，只搜索ID这棵B+树；
* 查询语句：`select * from T where k = 1`，普通索引方式，先找k索引B+树，找到对应的ID，再找ID索引树。**回表**； 

4.普通索引的查询会多扫描一棵索引树；

5.Innodb是一棵N叉树，N的值是1200；

6.提问：一张没有主键的表，只有1个普通索引，查询时怎么回表？

   Innodb默认会将RowId作为主键；

7.思考题：`老师你好：之前看过一遍文章，一直有疑惑：一个innoDB引擎的表，数据量非常大，根据二级索引搜索会比主键搜索快，文章阐述的原因是主键索引和数据行在一起，非常大搜索慢，我的疑惑是：通过普通索引找到主键ID后，同样要跑一遍主键索引，还望老师解惑。。。`

8. B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一。



### 覆盖索引

1.回表：回到主索引树搜索的过程，普通索引的查找就需要；

2.示例：`select ID from T where k between 3 and 5`，需要查找的ID在k索引树上已经存在了，可以直接获取结果，不需要回表。简而言之，在**这个查询里索引k已经覆盖了查询需求，称为覆盖索引**

3.**重点：覆盖索引可以减少树的搜索次数，提升查询性能，所以使用覆盖索引是常用的性能优化手段**；

4.思考通过身份证号去查询姓名，在身份证号建立索引 和 （身份证号、姓名）联合索引对比？

   使用联合索引可用到覆盖索引，不需要回表查，减少了执行时间

### 最左前缀原则

1.B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录，最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符；

示例，查询（姓名，年龄）联合索引的表，找已张开头的数据`where name like '张%'`索引仍然有效

2.联合索引内的字段顺序如何安排？

   **重点：第一原则，如果通过调整顺序，可以少维护一个索引，那么这个顺序就是优先考虑的**，示例（a, b）联合索引，则不需要在a上建立索引了。

3.MySQL5.6之后引入了**索引下推**，在索引遍历过程中，对索引包含的字段进行判断，过滤掉不满足条件的记录，减少回表次数；

4.提问，什么情况下需要重建索引？

  索引因为删除，或者页分裂等原因，使得数据页有空洞，重建索引会创建新的索引，把数据按顺序插入，使得页面利用率最高。语句：`Alter table T engine=Innodb`

示例：`让我想到了我们线上的一个表, 记录日志用的, 会定期删除过早之前的数据. 最后这个表实际内容的大小才10G, 而他的索引却有30G. 在阿里云控制面板上看,就是占了40G空间. 这可花的是真金白银啊.后来了解到是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.只能是重新建表才能重建索引.`

### 提问F&Q

1.联合索引的技巧？（覆盖索引，最左前缀原则，索引下推）

2.**好问题：**老师，下面两条语句有什么区别，为什么都提倡使用2:
   `1.select * from T where k in(1,2,3,4,5)`
   `2.select * from T where k between 1 and 5`

   第1个树搜索5次，第2个树搜索1次。
















